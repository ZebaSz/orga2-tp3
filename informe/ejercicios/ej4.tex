\section{Ejercicio 4: Unidad de Manejo de Memoria}
En la inicialización de la mmu, simplemente inicializamos el valor de la variable que nos dará la próxima página libre, este indica la dirección de memoria en donde comienzan las páginas libres. Cada vez que se requiera una página libre, se pedirá este valor y en caso de ocuparla se aumentará el valor a la próxima página libre.
, 
En la inicialización de del directorio de páginas y la tabla de páginas de una tarea, hay que tener en cuenta que debemos mappear el kernel con identity mapping y el código de la tarea en el mapa, por lo que debemos saber que tarea es, que jugador la lanza y la posicion y. Para ello se usó una función que haga el mapping del kernel, y después según qué jugador sea y la posición del zombie, mappeamos las páginas de la tarea a las correspondientes en el mapa.

Para el mappeo de páginas tenemos que descomponer la dirección virtual para obtener los índices de la PDE y la PTE, del cr3 podemos obtener la dirección al directorio de páginas. Una vez obtenida la dirección efectiva de la PDE, revisamos si la página no está presente, por lo que se tiene que crear una nueva página para esta entrada, se hace referencia a ella y se la setea presente, y en la PTE se carga la dirección física con los atributos de lecto-escritura y el bit de presente. Para desmappear, el procedimiento es muy similar, tras conseguir la dirección de la PTE y en la misma se configura el bit de presente en cero. Finalmente se llama a la función tblflush() que se encarga de limpiar el caché de traducciones para que el cambio sea reflejado.
